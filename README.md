# HWVL اولین هش ایرانی
### **قبل از معرفی HWVL بیایید بررسی کنیم که اصلا هش و هشینگ یعنی چه و چه کاربردی دارد**

---

### هش

تابع هش، یک تابع ریاضی است که ورودی با طول دلخواه را گرفته و خروجی با طول مشخص تولید می کند 

---

#### ✅ قطعی بودن
تابع هش در ازای یک ورودی مشخص، همواره مقدار هش ثابتی ارائه می‌دهد. یعنی اگر یک مقدار را چندین بار در تابع قرار دهید، خروجی همیشه یکسان خواهد بود.  
این ویژگی باعث می‌شود که پیگیری و بررسی داده‌ها آسان‌تر باشد. در غیر این صورت، کاربران با انبوهی از خروجی‌های متفاوت برای یک ورودی مواجه می‌شدند که تحلیل آن‌ها دشوار و زمان‌بر بود.

---

#### ⚡ سرعت بالا در محاسبه
تابع هش باید بتواند مقدار ورودی را در مدت‌زمان کوتاه به خروجی تبدیل کند.  
اگر سرعت این فرآیند پایین باشد، عملکرد کلی سیستم نیز کاهش می‌یابد و ناکارآمد خواهد بود.

---

#### 🔒 یک‌طرفه بودن

تابع هش رمزنگاری یک تابع یک‌طرفه است؛ یعنی:
- به‌راحتی می‌توان از ورودی به خروجی رسید،
- اما انجام عملیات معکوس (یعنی رسیدن از خروجی به ورودی) بسیار دشوار و در عمل غیرممکن است.

برای مثال اگر دامنه‌ی کوچکی مانند اعداد ۵ تا ۱۰ را به تابع بدهیم، ممکن است بتوان با آزمون و خطا ورودی را از خروجی بازسازی کرد. اما در دامنه‌های بزرگ‌تر، این فرایند زمان‌بر، بی‌نتیجه و عملاً غیرممکن است.

در این حالت، تنها روش ممکن **جستجوی جامع (brute-force)** است که شامل امتحان تمام ورودی‌های ممکن به‌صورت تصادفی است. این روش بسیار پرهزینه و ناکارآمد است و به همین دلیل به آن "بی‌خردانه" نیز گفته می‌شود.

---

#### 🌀 تغییر کامل خروجی با تغییر کوچک در ورودی
کوچک‌ترین تغییر در ورودی باعث ایجاد تغییر کامل در خروجی هش می‌شود.  

برای مثال، هنگام وارد کردن رمز عبور، اگر حتی یکی از کاراکترها تغییر کند، خروجی هش تغییر کرده و سیستم دیگر اجازه‌ی ورود نمی‌دهد.  
این ویژگی برای تشخیص صحت داده بسیار کلیدی و حیاتی است.

---

#### 🎯 یکتابودن مقدار هش برای هر ورودی
هر ورودی دارای یک هش منحصر‌به‌فرد است.  
یعنی امکان ندارد که دو ورودی متفاوت، خروجی هش یکسانی تولید کنند.

به‌عبارت دیگر:
> اگر `A ≠ B` باشد، آنگاه `Hash(A) ≠ Hash(B)` نیز برقرار است.

این ویژگی مانع بروز تصادم (collision) در سیستم‌های امنیتی و رمزنگاری می‌شود.

---

#### 📏 ثابت بودن طول خروجی
تابع هش بدون توجه به اندازه ورودی، همواره خروجی با طول ثابت تولید می‌کند.  

برای مثال:
`"سلام"`و
`"سلام خوبی"`
هر دو اگر به تابع هش داده شوند، خروجی‌هایی با طول دقیقاً یکسان تولید خواهند کرد.
این خاصیت باعث می‌شود که فضای ذخیره‌سازی بهینه باشد و پردازش‌ داده‌ها با سرعت و نظم بیشتری انجام شود.

---

### کاربرد الگوریتم های هش

زمانی که درون وب سایتی ثبت نام می کنید و یک رمز برای خود مشخص می کنید یا حتی زمانی که پسورد لاگین ویندوز را وارد می کنید رمز ورودی شما با تابع هش تبدیل به متن رمز شده می شود و درون ان برنامه یا وب سایت ذخیره می شود این گونه اگر کسی بخواهد رمز شما را به دست اورد و بخواهد ان را بشکند مثل یک قفل محکم است که هر چه رمز شما قوی تر باشد این قفل هم قوی تر است. خب شاید برای شما سوال شود که وب سایت یا برنامه چگونه می فهمد که رمزی که من وارد کرده ام درست است چون همان طور که گفتیم تقریبا غیر ممکن است؟

وب سایت ها رمز جدیدی که وارد کرده اید را به همان تابعی می دهند که قبلا از ان برای قفل کردن پسورد شما استفاده کرده بودند و این تابع دوباره ان رمز جدید را هش می کند بعد وب سایت یا برنامه هش این رمز جدید را با همان هش قبلی که ذخیره شده بود مقایسه می کند و اگر برابر بودند وارد برنامه یا وب سایت می شوید.با این تکنیک حتی اگر وب سایت هک شود رمز شما در امان خواهد بود

# HWVL

![](./img/HWVL.png)

__HWVL__ مخفف __Hash With Variable Length__
به معنی هش با طول متغیر است

این هش بر خلاف هش های دیگر دو مقدار می گیرد   
- متنی که می خواهد هش کند
- طول خروجی

طول خروجی علاوه بر مشخص کردن تعداد کاراکتر های خروجی در الگوریتم تاثیر فراوانی دارد هر چه این مقدار کمتر باشد احتمال برخورد بیشتر و سرعت هم بیشتر می شود و هر چه این مقدار بیشتر باشد باعث سخت شدن شکستن هش و کمتر شدن احتمال برخورد و کمتر شدن سرعت الگوریتم می شود.

یعنی این عدد رابطه مستقیم با امنیت الگوریتم دارد🔒

این الگوریتم دو نسخه دارد ما می خواهیم الگوریتم را با sha256 , sha512 , md5 و blake2b  مقایسه کنیم تست های صورت گرفته به شرح زیر است

| تست             | توضیح                                                                                     |
|-----------------|-------------------------------------------------------------------------------------------|
| **Bit Length**  | بررسی طول خروجی الگوریتم هش (HWVL) نسبت به الگوریتم‌های مرجع مثل SHA و MD5               |
| **Avalanche**   | بررسی حساسیت هش به تغییر کوچک در ورودی؛ درصد بیت‌های تغییر کرده در خروجی پس از تغییر ۱ کاراکتر ورودی |
| **Entropy**     | میزان تصادفی بودن خروجی هش؛ هر چه بیشتر باشد، بهتر است                                 |
| **Max Run**     | حداکثر طول دنباله بیت‌های یکسان متوالی در خروجی؛ عدد کمتر نشان‌دهنده پراکندگی بهتر بیت‌هاست |
| **Collision**   | بررسی احتمال وجود دو ورودی متفاوت که خروجی هش یکسانی تولید کنند (احتمال برخورد)        |
| **Preimage**    | بررسی سختی پیدا کردن ورودی از روی خروجی هش داده شده (حمله پیش‌تصویری)                   |
| **Second Preimage** | بررسی سختی یافتن ورودی دوم که هش آن با ورودی اول برابر باشد (حمله دوم پیش‌تصویری)         |

---

| معیار        | توضیح                            |
|--------------|---------------------------------|
| Avalanche    | حدود 33% ایده‌آل؛ کمتر یا بیشتر ❌ |
| Entropy      | بالاتر بهتر؛ زیر 3.5 ضعیف ❌     |
| Max Run      | کوچکتر بهتر؛ ≤ 6 خوب ✔️          |
| زمان اجرا    | کمتر بهتر؛ < 0.00001 سریع ✔️    |



>### __توجه کنید تمام ازمایش های با طول خروجی پیش فرض HWVL گرفته شده است__

![](./img/test.png)

| الگوریتم  | Avalanche (%)         | Entropy            | Max Run            | زمان اجرا (ثانیه)      | برخورد (Collision) | پیش‌تصویر (Preimage) | پیش‌تصویر دوم (Second Preimage) |
|-----------|-----------------------|--------------------|--------------------|------------------------|---------------------|-----------------------|---------------------------------|
| HWVL1     | 27.53% ❌             | 3.40 ❌             | 5.97 ✔️            | 0.000419 ❌             | ❌                  | ❌                    | ❌                              |
| HWVL2     | 42.18% ❌             | 4.65 ✔️            | 6.26 ❌            | 0.008819 ❌             | ❌                  | ❌                    | ❌                              |
| MD5       | 33.03% ✔️             | 3.61 ✔️            | 5.64 ✔️            | 0.000005 ✔️            | ❌                  | ❌                    | ❌                              |
| SHA1      | 32.97% ✔️             | 3.70 ✔️            | 5.79 ✔️            | 0.000004 ✔️            | ❌                  | ❌                    | ❌                              |
| SHA224    | 33.10% ✔️             | 3.79 ✔️            | 5.84 ✔️            | 0.000006 ✔️            | ❌                  | ❌                    | ❌                              |
| SHA256    | 33.18% ✔️             | 3.82 ✔️            | 5.92 ✔️            | 0.000005 ✔️            | ❌                  | ❌                    | ❌                              |
| SHA384    | 33.07% ✔️             | 3.88 ✔️            | 5.97 ✔️            | 0.000005 ✔️            | ❌                  | ❌                    | ❌                              |
| SHA512    | 33.02% ✔️             | 3.91 ✔️            | 6.00 ✔️            | 0.000006 ✔️            | ❌                  | ❌                    | ❌                              |
| BLAKE2b   | 32.97% ✔️             | 3.91 ✔️            | 5.99 ✔️            | 0.000003 ✔️            | ❌                  | ❌                    | ❌                              |
| BLAKE2s   | 33.03% ✔️             | 3.82 ✔️            | 5.91 ✔️            | 0.000003 ✔️            | ❌                  | ❌                    | ❌                              |
| SHA3_224  | 33.05% ✔️             | 3.79 ✔️            | 5.87 ✔️            | 0.000006 ✔️            | ❌                  | ❌                    | ❌                              |
| SHA3_256  | 33.03% ✔️             | 3.82 ✔️            | 5.91 ✔️            | 0.000005 ✔️            | ❌                  | ❌                    | ❌                              |
| SHA3_384  | 32.93% ✔️             | 3.89 ✔️            | 5.96 ✔️            | 0.000005 ✔️            | ❌                  | ❌                    | ❌                              |
| SHA3_512  | 32.98% ✔️             | 3.91 ✔️            | 5.99 ✔️            | 0.000006 ✔️            | ❌                  | ❌                    | ❌                              |

# نحوه استفاده

ابتدا مخزن را دانلود کنید. سپس کد های HWVL مورد نظر خود را کنار برنامه اصلی بگذارید و ان را به صورت ماژول وارد برنامه کنید مثلا اگر نسخه HWVL شما نسخه دوم است از کد زیر استفاده کنید:

```python
from HWVL2 import HWVL
print(HWVL("hello",20))

```
یا 

```python
from HWVL2 import HWVL
print(HWVL("hello"))

```

نسخه یک هم به همین صورت است

```python
from HWVL1 import HWVL
print(HWVL("hello"))

```
>### نکته: اگر به تابع مقدار دوم را ندهید به صورت پیش فرض طول ان 32 کاراکتر است

<br>

# الگوریتم اثبات کار جدید با HWVL
به لطف بیت کوین احتمالا همه شما با الگوریتم های اثبات کار اشنا هستید ولی برای کسانی که اشنایی ندارند به طور ساده الگوریتم های اثبات کار شبیه یک مساله ریاضی خیلی پیچیده است که از ان برای جلو گیری از جعل اطلاعات و افزایش امنیت استفاده می شود

ما به کمک HWVL توانستیم بین دو سیستم در شبکه lan یک ارتباط با اثبات کار پیاده سازی کنیم.اثبات کار به این صورت بود که کلاینت یک درخواست اتصال به سرور همراه با یک کلید عمومی می زد و سرور در پاسخ یک متن تصادفی با طول n(که سختی شبکه است)تولید می کرد و با  HWVL(key,40) و کلید عمومی رمز می کرد و می فرستاد

سپس کلاینت سعی می کرد ان را بشکند و متن اصلی را پیدا کند بعد از این کار با تابع HWVL(key) یک هش 32 کاراکتری می شاخت و به سرور می داد و سرور هم در پاسخ به او می گفت که ایا کرک هش او موفق امیز بوده است یا نه که اگر نه کلاینت دوباره این کار را انجام دهد

بعد از تایید سرور کلاینت و سرور توسط همان کلیدی که بین هم توافق کرده بودند شروع به رمزنگاری با کلید متقارن می کردند.  
از انجایی که همه ارتباط با رمزنگاری نا متقارن صورت می گرفت ارتباط امن بود

### مزایا

- مزیت این روش نسبت به روش های دیگر مثل دیفی هالمن جلو گیری از حمله dos بود که اگه کلاینت بخواهد به سرور حمله کند نتواند به راحتی ارتباط ایجاد کند و بیشتر از اینکه سرور را مشغول کند خودش مشغول کرک کردن هش می شود 

- یکی از روش های جلو گیری از حمله محروم سازی از سرویس مدیرت از روی ip است که اگر کلاینت از پروکسی استفاده کند یا در خواست ها از چند سیستم ارسال شود بهینه نیست که شرکت ها ارعه دهنده هاست سر همین موضوع با ضد dos ها و ضد ddos ها کلی سود می کنند 

#### یک مشکل

- کلاینت می تواند با ساخت جدولی از هش ها به سرور حمله کند که برای جلو گیری از کاراکتر هایی که ما مشخص می کنیم شروع به جست و جو هش اصلی می کند و با این روش می توانیم سختی شبکه را افزایش دهیم و مانع حملات dos یا ddos شویم

- کرک هش می تواند زمان بر باشد اما می توان با مدیریت سختی شبکه از این روش بهینه استفاده کرد 

---

برای مشارکت در توسعه این پروژه به این ایمل پیام دهید:`mohammad.rakhshkhorshid@gmail.com`  
امیدوارم که موفق باشید😊


---
منابع:  
`https://wallex.ir/blog/%D8%AA%D8%A7%D8%A8%D8%B9-%D9%87%D8%B4-%D8%A8%D9%87-%D8%B2%D8%A8%D8%A7%D9%86-%D8%B3%D8%A7%D8%AF%D9%87/`

---

برنامه نویس : محمد رخش خورشید 
سال تولید:1403-1404
